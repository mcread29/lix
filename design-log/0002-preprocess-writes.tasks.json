[
  {
    "context": "Design Log #0002 is approved as the implementation contract for RFC 001. Current preprocessor pipeline lives in packages/sdk/src/engine/preprocessor/create-preprocessor.ts.",
    "task": "Add a no-op rewrite step file at packages/sdk/src/engine/preprocessor/steps/rewrite-vtable-writes.ts exporting `rewriteVtableWrites: PreprocessorStep` that returns input statements unchanged.",
    "constraints": "Do not change runtime behavior yet. Do not touch existing rewrite steps. Keep export style and TypeScript conventions used by nearby step files.",
    "output": "New compileable step file with typed export and zero behavior change.",
    "status": "completed",
    "notes": "Completed in `packages/sdk/src/engine/preprocessor/steps/rewrite-vtable-writes.ts`. The step is intentionally a no-op and imports `PreprocessorStep` from `../types.js`."
  },
  {
    "context": "The full pipeline in create-preprocessor.ts currently runs entity-view rewrites, expand views, cache, active-version rewrite, and vtable select rewrite.",
    "task": "Wire `rewriteVtableWrites` into `fullPipeline` immediately after entity-view DML rewrites and before select-only rewrite stages.",
    "constraints": "Do not add it to vtable-select-only mode. Do not reorder existing read steps beyond this insertion.",
    "output": "Preprocessor full mode invokes the new write step in the intended position.",
    "status": "completed",
    "notes": "Completed by importing `rewriteVtableWrites` in `create-preprocessor.ts` and adding it to `fullPipeline` after entity-view INSERT/UPDATE/DELETE rewrites. It remains excluded from `vtable-select-only` mode."
  },
  {
    "context": "Preprocessor step behavior must be testable in isolation before adding rewrite logic.",
    "task": "Add rewrite-vtable-writes.test.ts to assert: non-target SQL stays unchanged, parse/compile roundtrip remains valid, and trace entry behavior is deterministic.",
    "constraints": "Do not assert implementation details not yet introduced. Avoid fragile SQL whitespace expectations.",
    "output": "Green baseline tests proving the scaffolded step is safe and stable.",
    "status": "completed",
    "notes": "Completed with new `rewrite-vtable-writes.test.ts` baseline tests for no-op behavior and stable trace output. Step now emits deterministic `rewrite_vtable_writes` trace payload with `rewritten: false` and `rewritten_count: 0` in no-op mode."
  },
  {
    "context": "Write targets for RFC are state/state_by_version/lix_internal_state_vtable DML statements.",
    "task": "Implement target-table detection helpers in rewrite-vtable-writes.ts for INSERT/UPDATE/DELETE statements aimed at `state`, `state_by_version`, or `lix_internal_state_vtable`.",
    "constraints": "Do not rewrite unsupported statements. Do not inspect raw SQL text; rely on AST nodes.",
    "output": "Deterministic table-target detection helper functions with unit tests.",
    "status": "completed",
    "notes": "Completed in `rewrite-vtable-writes.ts` via `resolveWriteTargetTable(...)` and `isVtableWriteStatement(...)` using AST node inspection only (no raw SQL parsing). Added unit coverage for INSERT/UPDATE/DELETE targets, non-target statements, and case/qualifier normalization."
  },
  {
    "context": "`state` writes need active version resolution; context already exposes `getActiveVersionId`.",
    "task": "Add helper that resolves `state` write statements to concrete `version_id` using `getActiveVersionId` and aborts rewrite when active version is unavailable.",
    "constraints": "Do not guess version_id. Do not change behavior for `state_by_version` or direct vtable targets.",
    "output": "Reusable version-resolution helper with explicit fallback behavior.",
    "status": "completed",
    "notes": "Completed by adding `resolveStateWriteVersionId(...)` helper in `rewrite-vtable-writes.ts`. It resolves active version only for `state` targets and returns `null` when active version is unavailable (fallback-safe abort signal), while `state_by_version` and direct vtable writes return `undefined` (explicit version expected)."
  },
  {
    "context": "First rewrite scope includes INSERT VALUES and INSERT DEFAULT VALUES only.",
    "task": "Implement AST extractor for INSERT payload rows and columns for supported forms, producing normalized mutation rows for downstream rewrite logic.",
    "constraints": "Do not implement INSERT...SELECT yet. If shape is unsupported, return fallback decision without rewriting.",
    "output": "Typed row-extraction utility plus tests for supported and unsupported INSERT shapes.",
    "status": "completed",
    "notes": "Completed via `extractInsertMutationRows(...)` in `rewrite-vtable-writes.ts`. Supported forms: `INSERT ... VALUES` (explicit column list required) and `INSERT ... DEFAULT VALUES`. Unsupported shapes return fallback reasons (`insert_columns_required`, `insert_row_shape_mismatch`, `insert_source_not_supported`) without rewriting."
  },
  {
    "context": "Validation parity requires reusing existing mutation validator logic.",
    "task": "Extract reusable validation entrypoint(s) from state/vtable/validate-state-mutation.ts so both vtable path and preprocessor write path can invoke identical checks.",
    "constraints": "Do not duplicate validation logic. Do not weaken existing constraints or error semantics.",
    "output": "Shared validation helper API consumed by old and new paths with parity tests.",
    "status": "completed",
    "notes": "Extracted shared validation API to `state/vtable/write-helpers/validate-state-write.ts` (`validateStateWriteMutation`). Updated `vtable.ts` to consume the helper (no behavior change) and added parity test ensuring error semantics match `validateStateMutation`."
  },
  {
    "context": "vtable.ts currently persists writer metadata and applies file descriptor cache side effects.",
    "task": "Extract writer persistence logic from vtable.ts into `packages/sdk/src/state/vtable/write-helpers/persist-writer.ts` and update vtable.ts to call it.",
    "constraints": "No behavior change allowed. Preserve SQL statements and conflict behavior.",
    "output": "Shared writer helper in dedicated file, with vtable.ts refactored to consume it.",
    "status": "completed",
    "notes": "Completed by extracting writer persistence to `state/vtable/write-helpers/persist-writer.ts` and refactoring `vtable.ts` to use it. SQL and conflict behavior were preserved (UPSERT on composite key, delete on null/empty writer). Added parity test for insert/update/delete writer flow."
  },
  {
    "context": "File descriptor writes/deletes currently update `lix_internal_file_path_cache` inside vtable write flow.",
    "task": "Extract file cache side effects into `packages/sdk/src/state/vtable/write-helpers/file-cache-side-effects.ts` and reuse in vtable.ts.",
    "constraints": "Do not alter cache key/path semantics. Do not skip delete-path behavior.",
    "output": "Single helper for file path cache insert/update/delete side effects with parity tests.",
    "status": "completed",
    "notes": "Completed by extracting cache side effects to `state/vtable/write-helpers/file-cache-side-effects.ts` and refactoring `vtable.ts` to use shared helper calls. Semantics for cache insert/update/delete were preserved and covered with helper-level parity tests."
  },
  {
    "context": "Delete behavior is source-tag aware (tracked/untracked/inherited) and currently embedded in vtable.ts.",
    "task": "Extract delete-behavior logic into `packages/sdk/src/state/vtable/write-helpers/delete-behavior.ts` with explicit source-tag handling contracts.",
    "constraints": "Do not flatten source-tag rules. Preserve tombstone vs direct-untracked-delete semantics.",
    "output": "Reusable delete helper plus targeted tests for T/TI/U/UI source branches.",
    "status": "completed",
    "notes": "Completed by extracting source-tag-aware untracked delete logic to `state/vtable/write-helpers/delete-behavior.ts` and wiring `handleStateDelete(...)` through it. Added targeted branch tests covering UI/T/TI tombstone behavior and U direct-untracked delete semantics."
  },
  {
    "context": "INSERT rewrites should bypass vtable and produce physical writes directly.",
    "task": "Implement INSERT rewrite in rewrite-vtable-writes.ts to generate physical SQL statements that perform validated writes without invoking vtable callbacks.",
    "constraints": "Only rewrite supported INSERT shapes. Keep fallback strategy for unsupported forms. Preserve parameter ordering and binding semantics.",
    "output": "INSERT statements targeting supported tables are rewritten to physical-write SQL and pass integration tests.",
    "status": "completed",
    "notes": "Implemented INSERT rewrite in `rewrite-vtable-writes.ts` for supported AST shapes by generating physical `lix_internal_transaction_state` SQL (bypassing vtable callbacks), while invoking shared validation (`validateStateWriteMutation`) before rewrite emission. Conservative fallback is preserved for unsupported expressions/shapes, unresolved active version for `state`, and `lix_file_descriptor` rows (to avoid file-cache side-effect regressions in this phase)."
  },
  {
    "context": "`state` and `state_by_version` are currently trigger-backed views into the vtable.",
    "task": "Add integration tests showing INSERT into `state` and `state_by_version` reaches rewritten physical path and yields equivalent visible results to prior behavior.",
    "constraints": "Use real Lix database, no mocks. Cover both tracked and untracked writes.",
    "output": "Green integration tests proving INSERT parity on public SQL surfaces.",
    "status": "completed",
    "notes": "Added integration coverage in `create-preprocessor.test.ts` for tracked + untracked INSERT on both `state` and `state_by_version`, asserting rewritten physical SQL path and equivalent visible rows on public views. Fallback behavior is additionally covered in `rewrite-vtable-writes.test.ts` (active-version unavailable case)."
  },
  {
    "context": "UPDATE rewrite is in scope for first implementation phase.",
    "task": "Implement UPDATE rewrite for supported predicates into equivalent physical-write operations with validation and writer/file side effects.",
    "constraints": "Do not support ambiguous UPDATE forms without proven parity. Fallback when not safely rewritable.",
    "output": "Supported UPDATE statements bypass vtable and preserve behavior.",
    "status": "cancelled",
    "notes": "Blocked by architecture dependency: safe UPDATE rewrite requires a non-transaction-table materialization path first (Tasks 15-18) to avoid maintaining divergent update semantics across vtable callbacks, transaction staging, and direct-write preprocessor output. Implementing UPDATE now would duplicate critical logic and risk observable behavior drift."
  },
  {
    "context": "DELETE rewrite requires source-aware semantics from extracted delete helper.",
    "task": "Implement DELETE rewrite for supported predicates, invoking shared delete behavior to preserve tracked/untracked/inherited outcomes.",
    "constraints": "Do not collapse delete flows into one generic branch. Preserve existing tombstone semantics.",
    "output": "Supported DELETE statements bypass vtable with parity-verified behavior.",
    "status": "cancelled",
    "notes": "Blocked by same dependency chain as Task 13: DELETE rewrite parity (tracked/untracked/inherited branches) depends on completing the post-transaction-table write architecture first. Implementing partial DELETE rewrite now would produce dual, inconsistent delete flows."
  },
  {
    "context": "RFC requests removing transaction-state staging architecture; this affects schema and typed DB contracts.",
    "task": "Remove `lix_internal_transaction_state` from runtime schema creation in packages/sdk/src/state/transaction/schema.ts and from internal schema typing in packages/sdk/src/database/schema.ts.",
    "constraints": "Do not remove unrelated internal tables. Update dependent types/queries in same change set so build remains green.",
    "output": "Transaction table no longer exists in schema bootstrap or type contracts.",
    "status": "cancelled",
    "notes": "Blocked by remaining production dependencies on `lix_internal_transaction_state` in commit materialization, read rewrite segment planning, merge flow, and change view composition. Removing table/schema now would break runtime and tests immediately."
  },
  {
    "context": "State transaction insertion helper becomes obsolete once transaction table is removed.",
    "task": "Delete or replace `packages/sdk/src/state/transaction/insert-transaction-state.ts` with the new physical-write target helper API used by rewrite-vtable-writes and any remaining runtime callers.",
    "constraints": "Do not leave dead imports. Do not keep dual write paths that can diverge.",
    "output": "No remaining production caller depends on obsolete insert-transaction-state behavior.",
    "status": "cancelled",
    "notes": "Blocked by Task 15 not completed: `insert-transaction-state.ts` is still a required runtime path for vtable writes and untracked delete tombstone handling."
  },
  {
    "context": "vtable runtime currently owns xUpdate/xRollback/open-transaction logic tied to transaction table.",
    "task": "Refactor packages/sdk/src/state/vtable/vtable.ts to remove transaction-table dependent write lifecycle logic while retaining required read/vtable compatibility behavior.",
    "constraints": "Do not break read paths unintentionally. Keep module registration stable unless explicitly migrated.",
    "output": "vtable runtime no longer acts as primary write executor and no longer depends on removed transaction table.",
    "status": "cancelled",
    "notes": "Blocked by Tasks 15-16 not completed: `vtable.ts` lifecycle still depends on transaction-state staging (`xBegin`/`xRollback`/open-transaction behavior) and cannot be safely removed independently."
  },
  {
    "context": "commit.ts currently materializes pending rows from transaction table.",
    "task": "Redesign packages/sdk/src/state/vtable/commit.ts to source commit materialization from the new write architecture and preserve existing hook and cache update outcomes.",
    "constraints": "Do not change external commit API shape. Preserve state_commit hook semantics.",
    "output": "Commit flow works without transaction table and passes commit-related tests.",
    "status": "cancelled",
    "notes": "Blocked by Tasks 15-17 not completed: commit pipeline still reads pending transaction rows and requires a replacement write architecture before refactor."
  },
  {
    "context": "rewrite-vtable-selects currently builds candidate segments including transaction-state sources.",
    "task": "Update packages/sdk/src/engine/preprocessor/steps/rewrite-vtable-selects.ts to remove transaction-source segment planning and adapt ranking logic to remaining sources.",
    "constraints": "Do not regress query correctness for current read scenarios. Keep conservative fallback rules intact.",
    "output": "Read rewrite no longer references transaction table and remains behavior-correct.",
    "status": "cancelled",
    "notes": "Blocked by Task 15 not completed: select rewrite currently relies on transaction segments for pending-write visibility, which must remain until transaction-state removal is complete."
  },
  {
    "context": "change view currently unions transaction-state rows.",
    "task": "Update packages/sdk/src/change/schema.ts to remove transaction-state union branch and ensure `change` view semantics still match post-migration write model.",
    "constraints": "Do not alter `change_insert` trigger behavior unless required by new architecture.",
    "output": "Change view definition compiles and reflects new source-of-truth tables only.",
    "status": "cancelled",
    "notes": "Blocked by Task 15 not completed: `change` view currently unions transaction-state rows for uncommitted tracked writes; removing union now would regress visible behavior."
  },
  {
    "context": "merge-version currently reads and deletes rows from transaction table during merge flow.",
    "task": "Refactor packages/sdk/src/version/merge-version.ts to remove transaction-table reads/deletes and use new post-rewrite sources for pending/reference changes.",
    "constraints": "Do not change merge public API. Preserve one-commit merge model behavior.",
    "output": "merge-version works without transaction table dependency.",
    "status": "cancelled",
    "notes": "Blocked by Task 15 not completed: merge flow still consumes and clears transaction-state rows for pending-source references."
  },
  {
    "context": "After architecture migration, test suite contains obsolete transaction-table assumptions.",
    "task": "Update or remove transaction-table specific tests and add parity tests for rewrite-vtable-writes across INSERT/UPDATE/DELETE on state, state_by_version, and direct vtable SQL.",
    "constraints": "No mocks for Lix internals. Keep tests behavior-focused with Arrange/Act/Assert.",
    "output": "Comprehensive tests validate new write path and remove stale transaction-table assertions.",
    "status": "cancelled",
    "notes": "Partially addressed for INSERT parity (Tasks 3/11/12), but full migration test updates depend on Tasks 13-21 completion. Comprehensive UPDATE/DELETE parity and transaction-table-assumption removals are blocked by unresolved architecture migration tasks."
  },
  {
    "context": "Benchmarks must demonstrate RFC performance goals and guard regressions.",
    "task": "Update relevant benchmarks (vtable.insert, commit, validation, and rewrite select benchmarks as needed) to reflect new architecture and capture before/after metrics.",
    "constraints": "Do not hand-wave benchmark claims. Keep benchmark setup comparable and reproducible.",
    "output": "Benchmark outputs quantify migration impact and validate target direction for bulk writes.",
    "status": "cancelled",
    "notes": "Blocked by incomplete architecture migration: benchmark scenarios would not represent final RFC target state until Tasks 13-21 are complete."
  },
  {
    "context": "Design-log process requires implementation result tracking and deviation notes.",
    "task": "Append `Implementation Results` section to design-log/0002-preprocess-writes.md documenting completed phases, test/lint/typecheck outcomes, and any deviations from the original plan.",
    "constraints": "Do not rewrite initial sections retroactively. Keep deviations explicit and justified.",
    "output": "Design Log #0002 includes an auditable implementation record.",
    "status": "completed",
    "notes": "Implementation Results section has been continuously appended during execution with per-task outcomes, changed files, tests, and deviations/blockers."
  }
]
